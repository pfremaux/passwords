/*
 * This file was generated by the Gradle 'init' task.
 *
 * This is a general purpose Gradle build.
 * Learn how to create Gradle builds at https://guides.gradle.org/creating-new-gradle-builds
 */
/*
Usage for build :
gradle :makeBuild
 */

apply {
    plugins.apply('java')
}

allprojects {
    repositories {
        // Use jcenter for resolving dependencies.
        // You can declare any Maven/Ivy/file repository here.
        jcenter()
    }
}

dependencies {
    implementation(project(":commons-lib"))
    implementation(project(":passwords-app"))
}

// Setting a default value but it should always be overrode
def versionApp = 'dev-' + new Date().format('yyyy.MM.dd.HH.mm')

/*
This task will generate a "fat jar" (will contains all the dependencies).
It relies on a file :'build-setup.properties'
This file is optional if you don't have one, this task will build
a SNAPSHOT-0.0.0 version and generate this properties file as well.
*/
task makeBuild() {
    // by running "gradle tasks --group custom" you'll be able to visualize
    // all tasks where you set this line
    group = "custom"
    // the description will be ouput while running the same command
    description = "SNAPSHOT/RELEASE depending on build-setup.properties"

    def majorVersion = 0
    def mediumVersion = 0
    def minorVersion = 0
    def prefix = 'SNAPSHOT-'
    def isDevBuild = project.hasProperty("dev") // test with -Pdev
    def props = new Properties()
    String setupFileName = "build-setup.properties"
    logger.info("loading setup file {}", setupFileName)
    def file = file(setupFileName)
    if (file.exists()) {
        file.withInputStream { props.load(it) }
        String latestRelease = props.getProperty("release.recent")
        boolean release = Boolean.parseBoolean(props.getProperty("release.flag").toString())
        if (release) {
            logger.info("Preparing release...")
            prefix = ''
        }
        String changeType = props.getProperty("release.next.change.type")
        logger.info("Change type {}", changeType)
        String[] v = latestRelease.split("\\.")
        if ("major".equals(changeType)) {
            majorVersion = Integer.parseInt(v[0]) + 1
        } else if ("feature".equals(changeType)) {
            majorVersion = Integer.parseInt(v[0])
            mediumVersion = Integer.parseInt(v[1]) + 1
        } else if ("fix".equals(changeType)) {
            majorVersion = Integer.parseInt(v[0])
            mediumVersion = Integer.parseInt(v[1])
            minorVersion = Integer.parseInt(v[2]) + 1
        } else if (!isDevBuild && "none".equals(changeType)) {
            logger.warn("release.next.change.type is 'none' if you want to increment the version please set it to fix/feature/major...")
        }
    }
    String newVersion = majorVersion + "." + mediumVersion + "." + minorVersion
    versionApp = prefix + newVersion
    logger.info("Preparing the fat jar with the version '{}'", versionApp)
    dependsOn("build")
    dependsOn("commons-lib:build")
    dependsOn("uberJar")
    if (!isDevBuild) doLast {
        logger.info("Updating file '{}'...", setupFileName)
        File propsFile = new File(setupFileName)
        props.setProperty("release.recent", newVersion)
        props.setProperty("release.flag", "false")
        props.setProperty("release.next.change.type", "none")
        props.store(propsFile.newWriter(), null)
    }
}

task uberJar(type: Jar) {
    archiveClassifier = project.hasProperty("dev") ? "dev" : versionApp
    from {
        configurations.runtimeClasspath.findAll { it.name.endsWith('jar') }
                .collect {
                    zipTree(it)
                }
    }
    manifest {
        attributes(
                'Main-Class': 'passwords.LauncherNew',
                'Manifest-Version': versionApp
        )
    }
}